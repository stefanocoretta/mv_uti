---
title: mvgam_uti
authors:
  - name: Norah Jones
    affiliation: The University
    roles: writing
    corresponding: true
bibliography: references.bib
---

```{r}
#| label: setup

library(tidyverse)
theme_set(theme_light())
```

## GAM

### CV coarticulation

```{r}
#| label: dlc-voff

dlc_voff_f <- readRDS("data/coretta2018/dlc_voff_f.rds") |> 
  
```

```{r}
#| label: fig-voff

dlc_voff_f |> 
  ggplot(aes(X_z, Y_z, group = frame_id)) +
  geom_path(alpha = 0.5) +
  coord_fixed() +
  facet_wrap(vars(speaker), ncol = 5)
```

```{r}
#| label: fig-pl04
#| fig-cap: "Tongue contours of PL04 (Polish) taken from the offset of vowels followed by coronal or velar stops. Tip is on the right."
dlc_voff_f |> 
  filter(speaker == "pl04") |> 
  ggplot(aes(X_z, Y_z, group = frame_id, colour = vowel)) +
  geom_path(alpha = 0.5) +
  coord_fixed() +
  facet_grid(cols = vars(c2_place)) +
  labs(x = "X (z-scores)", "Y (z-scores)")
```


```{r}
#| label: voff-gam

library(mgcv)

fi <- "data/cache/voff_gam.rds"

if (file.exists(fi)) {
  voff_gam <- readRDS(fi)
} else {
  voff_gam <- gam(
    list(
      X_z ~ vow_place_lang +
        s(knot, by = vow_place_lang, k = 5) +
        s(knot, speaker, by = vow_place, bs = "fs", m = 1),
      Y_z ~ vow_place_lang +
        s(knot, by = vow_place_lang, k = 5) +
        s(knot, speaker, by = vow_place, bs = "fs", m = 1)
    ),
    data = dlc_voff_f,
    family = mvn(d = 2)
  )
  
  saveRDS(voff_gam, fi)
}
```

```{r}
#| label: voff-pred

frame_voff <- expand_grid(
  speaker = unique(dlc_voff_f$speaker),
  vow_place_lang = unique(dlc_voff_f$vow_place_lang),
  knot = seq(0, 10, by = 0.1)
) |> 
  mutate(
    vow_place = str_remove(vow_place_lang, "\\.Italian"),
    vow_place = str_remove(vow_place, "\\.Polish"),
  )

excl <- c(
  "s(knot,speaker):vow_placea.coronal",
  "s(knot,speaker):vow_placeo.coronal",
  "s(knot,speaker):vow_placeu.coronal",
  "s(knot,speaker):vow_placea.velar",
  "s(knot,speaker):vow_placeo.velar",
  "s(knot,speaker):vow_placeu.velar",
  "s.1(knot,speaker):vow_placea.coronal",
  "s.1(knot,speaker):vow_placeo.coronal",
  "s.1(knot,speaker):vow_placeu.coronal",
  "s.1(knot,speaker):vow_placea.velar",
  "s.1(knot,speaker):vow_placeo.velar",
  "s.1(knot,speaker):vow_placeu.velar"
)

voff_gam_p <- predict(voff_gam, frame_voff, se.fit = TRUE, exclude = excl) |>
  as.data.frame() |>
  as_tibble()
colnames(voff_gam_p) <- c("X", "Y", "X_se", "Y_se")

voff_gam_p <- bind_cols(frame_voff, voff_gam_p) |> 
  # pick any speaker, random effects have been removed
  filter(speaker == "it01") |> 
  mutate(
    X_lo = X - (1.96 * X_se),
    X_hi = X + (1.96 * X_se),
    Y_lo = Y - (1.96 * Y_se),
    Y_hi = Y + (1.96 * Y_se)
  ) |> 
  separate(vow_place_lang, c("vowel", "place", "language"))
```

```{r}
#| label: fig-voff-pred
#| fig-cap: "Predicted tongue contours based on a multivariate GAM. Uncertainty not shown."
voff_gam_p |> 
  ggplot(aes(X, Y, colour = vowel)) +
  geom_point(alpha = 0.5) +
  facet_grid(cols = vars(place), rows = vars(language)) +
  coord_fixed() +
  labs(
    x = "X (z-scores)",
    y = "Y (z-scores)"
  )
```


```{r}
#| label: fig-voff-ci
#| fig-cap: "Predicted tongue contours based on a multivariate GAM, with 95% Confidence Intervals."
#| warning: false

voff_gam_p |> 
  group_by(place, vowel, language) |> 
  mutate(
    Y_lo = ifelse(Y_lo > min(Y), Y_lo, NA),
    X_hi = ifelse(X_hi < max(X), X_hi, NA),
  ) |> 
  ggplot(aes(X, Y, colour = vowel)) +
  geom_errorbarh(aes(xmin = X_lo, xmax = X_hi), alpha = 0.5) +
  geom_errorbar(aes(ymin = Y_lo, ymax = Y_hi), alpha = 0.5) +
  geom_point(size = 1, alpha = 0.75) +
  scale_color_brewer(type = "qual", palette = "Dark2") +
  coord_fixed() +
  facet_grid(cols = vars(place), rows = vars(language)) +
  theme_light() +
  theme(legend.position = "bottom")
```





```{r}
frame_voff <- expand_grid(
  speaker = unique(dlc_voff_f$speaker),
  vow_place_lang = unique(dlc_voff_f$vow_place_lang),
  knot = seq(0, 10)
) |> 
  mutate(
    vow_place = str_remove(vow_place_lang, "\\.Italian"),
    vow_place = str_remove(vow_place, "\\.Polish"),
  )

pred_grid_a <- filter(
  frame_voff, vow_place_lang == "a.coronal.Italian",
  speaker == "it01"
)
pred_grid_b <- filter(
  frame_voff, vow_place_lang == "u.coronal.Italian",
  speaker == "it01"
)

pred_a <- predict.gam(voff_gam, pred_grid_a, type = "lpmatrix") |> 
  as_tibble() |> 
  mutate(
    across(starts_with("s(knot,speaker)"), ~0)
  ) |> 
  as.matrix()
pred_a[,1:870] <- 0

pred_b <- predict.gam(voff_gam, pred_grid_b, type = "lpmatrix") |> 
  as_tibble() |> 
  mutate(
    across(starts_with("s(knot,speaker)"), ~0)
  ) |> 
  as.matrix()
pred_b[,1:870] <- 0

pred_diff <- pred_a - pred_b
diff <- as.vector(pred_diff %*% stats::coef(voff_gam))

se <- sqrt(rowSums((pred_diff %*% stats::vcov(voff_gam)) * pred_diff))

diff_out <- pred_grid_a
diff_out$diff <- diff
diff_out$se <- se
diff_out$lower_ci <- diff - se * 1.96
diff_out$upper_ci <- diff + se * 1.96
```

```{r}
diff_out |> 
  ggplot(aes(knot, diff)) +
  geom_hline(yintercept = 0) +
  geom_ribbon(aes(ymin = lower_ci, ymax = upper_ci), alpha = 0.5) +
  geom_point()
```

### Emphaticness

```{r}
#| label: dlc-emph

dlc_emph_f <- readRDS("data/sakr2025/dlc_emph_f.rds")
```

```{r}
#| label: emph-gam

library(mgcv)

fi <- "data/cache/emph_gam.rds"

if (file.exists(fi)) {
  emph_gam <- readRDS(fi)
} else {
  emph_gam <- gam(
    list(
      X_z ~ vow_emph +
        s(knot, by = vow_emph, k = 5) +
        s(knot, participant, by = vow_emph, bs = "fs", m = 1, k = 5),
      Y_z ~ vow_emph +
        s(knot, by = vow_emph, k = 5) +
        s(knot, participant, by = vow_emph, bs = "fs", m = 1, k = 5)
    ),
    data = dlc_emph_f,
    family = mvn(d = 2)
  )
  
  saveRDS(emph_gam, fi)
}
```

```{r}
#| label: emph-pred

frame_emph <- expand_grid(
  participant = unique(dlc_emph_f$participant),
  vow_emph = unique(dlc_emph_f$vow_emph),
  knot = seq(0, 10, by = 0.1)
)

excl <- c(
  "s(Knot,participant):vow_emphA.Emphatic",
  "s(Knot,participant):vow_emphE.Emphatic",
  "s(Knot,participant):vow_emphI.Emphatic",
  "s(Knot,participant):vow_emphO.Emphatic",
  "s(Knot,participant):vow_emphU.Emphatic",
  "s.1(Knot,participant):vow_emphA.Emphatic",
  "s.1(Knot,participant):vow_emphE.Emphatic",
  "s.1(Knot,participant):vow_emphI.Emphatic",
  "s.1(Knot,participant):vow_emphO.Emphatic",
  "s.1(Knot,participant):vow_emphU.Emphatic",
  "s(Knot,participant):vow_emphA.Plain",
  "s(Knot,participant):vow_emphE.Plain",
  "s(Knot,participant):vow_emphI.Plain",
  "s(Knot,participant):vow_emphO.Plain",
  "s(Knot,participant):vow_emphU.Plain",
  "s.1(Knot,participant):vow_emphA.Plain",
  "s.1(Knot,participant):vow_emphE.Plain",
  "s.1(Knot,participant):vow_emphI.Plain",
  "s.1(Knot,participant):vow_emphO.Plain",
  "s.1(Knot,participant):vow_emphU.Plain"
)

emph_gam_p <- predict(emph_gam, frame_emph, se.fit = TRUE, exclude = excl) |>
  as.data.frame() |>
  as_tibble()
colnames(emph_gam_p) <- c("X", "Y", "X_se", "Y_se")

emph_gam_p <- bind_cols(frame_emph, emph_gam_p) |> 
  # pick any speaker, random effects have been removed
  filter(participant == "Sak") |> 
  mutate(
    X_lo = X - (1.96 * X_se),
    X_hi = X + (1.96 * X_se),
    Y_lo = Y - (1.96 * Y_se),
    Y_hi = Y + (1.96 * Y_se)
  ) |> 
  separate(vow_emph, c("vowel", "emph"))
```

```{r}
#| label: fig-emph-pred

emph_gam_p |> 
  ggplot(aes(X, Y, colour = emph)) +
  geom_point() +
  facet_grid(cols = vars(vowel)) +
  coord_fixed() +
  theme(legend.position = "bottom")
```

```{r}
#| label: fig-emph-ci

emph_gam_p |> 
  ggplot(aes(X, Y, colour = emph)) +
  geom_errorbarh(aes(xmin = X_lo, xmax = X_hi), alpha = 0.25) +
  geom_errorbar(aes(ymin = Y_lo, ymax = Y_hi), alpha = 0.25) +
  geom_point(size = 1, alpha = 0.75) +
  scale_color_brewer(type = "qual", palette = "Dark2") +
  coord_fixed() +
  facet_grid(cols = vars(vowel)) +
  theme_light() +
  theme(legend.position = "bottom")
```


```{r}
#| label: emph-part
emph_gam_p_2 <- predict(emph_gam, frame_emph, se.fit = TRUE) |>
  as.data.frame() |>
  as_tibble()
colnames(emph_gam_p_2) <- c("X", "Y", "X_se", "Y_se")

emph_gam_p_2 <- bind_cols(frame_emph, emph_gam_p_2) |>
  mutate(
    X_lo = X - (1.96 * X_se),
    X_hi = X + (1.96 * X_se),
    Y_lo = Y - (1.96 * Y_se),
    Y_hi = Y + (1.96 * Y_se)
  ) |> 
  separate(vow_emph, c("vowel", "emph"))
```

```{r}
#| label: fig-emph-part
emph_gam_p_2 |> 
  ggplot(aes(X, Y, colour = emph)) +
  geom_errorbarh(aes(xmin = X_lo, xmax = X_hi), alpha = 0.5) +
  geom_errorbar(aes(ymin = Y_lo, ymax = Y_hi), alpha = 0.5) +
  # geom_point() +
  facet_grid(rows = vars(participant), cols = vars(vowel)) +
  coord_fixed()
```

```{r}
frame_emph <- expand_grid(
  participant = unique(dlc_emph_f$participant),
  vow_emph = unique(dlc_emph_f$vow_emph),
  knot = 0:10
)

pred_grid_a <- filter(
  frame_emph, vow_emph == "E.plain",
  participant == "Sak"
)
pred_grid_b <- filter(
  frame_emph, vow_emph == "E.emphatic",
  participant == "Sak"
)

pred_a <- predict.gam(emph_gam, pred_grid_a, type = "lpmatrix") |> 
  as_tibble() |> 
  mutate(
    across(starts_with("s(knot,participant)"), ~0)
  ) |> 
  as.matrix()
# pred_a[,301:603] <- 0
pred_a[,1:300] <- 0

pred_b <- predict.gam(emph_gam, pred_grid_b, type = "lpmatrix") |> 
  as_tibble() |> 
  mutate(
    across(starts_with("s(knot,participant)"), ~0)
  ) |> 
  as.matrix()
# pred_b[,301:603] <- 0
pred_b[,1:300] <- 0

pred_diff <- pred_a - pred_b
diff <- as.vector(pred_diff %*% stats::coef(emph_gam))

se <- sqrt(rowSums((pred_diff %*% stats::vcov(emph_gam)) * pred_diff))

diff_out <- pred_grid_a
diff_out$diff <- diff
diff_out$se <- se
diff_out$lower_ci <- diff - se * 1.96
diff_out$upper_ci <- diff + se * 1.96
```

```{r}
diff_out |> 
  ggplot(aes(knot, diff)) +
  geom_hline(yintercept = 0) +
  geom_ribbon(aes(ymin = lower_ci, ymax = upper_ci), alpha = 0.5) +
  geom_point()
```


## FPCA

### CV coarticulation

```{r}
#| label: attach-fda
library(fda)
library(funData)
library(MFPCA)
# install.packages("devtools")
# devtools::install_github("uasolo/landmarkregUtils")
library(landmarkregUtils)
```

```{r}
#| label: dlc-voff-long

dlc_voff_long <- dlc_voff_f |> 
  dplyr::select(X_z, Y_z, frame_id, knot, vowel, c2_place, language, speaker) |> 
  pivot_longer(c(X_z, Y_z), names_to = "dim") |> 
  group_by(dim, speaker) |> 
  mutate(
    value = (value - mean(value)) / sd(value)
  ) |> 
  ungroup()
```

```{r}
# build a multiFunData object
curves_fun_2d <- lapply(
  c("X_z", "Y_z"),
  function(y) {
    long2irregFunData(
      dlc_voff_long |> filter(dim == {{y}}),
      id = "frame_id",
      time = "knot",
      value = "value"
    ) |> 
    as.funData()
  }
) |> 
  multiFunData()
```

```{r}
# Compute FPCA
n_pc <- 2
mfpca <- MFPCA(
  curves_fun_2d,
  M = n_pc,
  uniExpansions = list(list(type = "uFPCA"), list(type = "uFPCA"))
)
```

```{r}
# Prop of explained var
mfpca$values  / sum( mfpca$values)
```

```{r}
# scores st. dev.
sd_fun <- sqrt(mfpca$values)

# PC curves to be plotted
pc_curves <- expand_grid(
  PC = 1:n_pc,
  dim = 1:2, 
  sd_frac = seq(-1, 1, by=.25)
) |> 
  group_by(PC, dim, sd_frac) |> 
  reframe(
    funData2long1(
      mfpca$meanFunction[[dim]] +
        sd_frac * sd_fun[PC] * mfpca$functions[[dim]][PC],
      time= "knot", value = "value"
    )
  ) |> 
  mutate(
    dim = factor(dim, levels = c(2,1), labels = c('Y_z', 'X_z'))
  )
```

```{r}
pc_curves |> 
  ggplot(aes(
    x = knot, y = value, group = sd_frac, color = sd_frac
  )) +
  geom_line() +
  scale_color_gradient2(
    low = "#762a83", mid = "grey", high = "#1b7837",
    breaks = c(-1, 0 , 1)
  ) +
  facet_grid(
    cols = vars(PC), rows = vars(dim),
    scales = "free_y",
    labeller = labeller(PC = ~str_glue("PC{.x}"))
  ) +
  labs(color = expression(frac(s[k], sigma[k]))) +
  geom_line(
    data = pc_curves |> filter(sd_frac == 0),
    color = 'black', linewidth = 1.2
  )
```

```{r}
#| label: pc-curves-wide

pc_curves_wide <- pc_curves |> 
  pivot_wider(names_from = dim)
```

```{r}
#| label: fig-curves-wide

pc_curves_wide |> 
  ggplot(aes(x = X_z, y = Y_z, group = sd_frac, color = sd_frac)) +
  geom_path() +
  scale_color_gradient2(
    low = "#762a83", mid = "grey", high = "#1b7837",
    breaks = c(-1, 0 , 1)
  ) +
  facet_wrap(
    vars(PC),
    labeller = labeller(PC = ~str_glue("PC{.x}"))
  ) +
  coord_fixed()
```


```{r}
# collect PC scores
pc_scores <- mfpca$scores |>
  `colnames<-`( paste0("PC", 1:n_pc)) |>
  as_tibble() |>
  bind_cols(dlc_voff_long |> distinct(frame_id, vowel, c2_place, language))

# scatterplot PC scores s1 and s2 by Category
pc_scores |> 
  filter(PC2 < 0.5) |>
  ggplot(aes(x = PC1, y = PC2, color = vowel)) +
  geom_point() +
  stat_ellipse() +
  facet_grid(cols = vars(c2_place), rows = vars(language)) +
  scale_color_brewer(palette = "Dark2")
```

### Emphaticness

```{r}
library(fda)
library(funData)
library(MFPCA)
# install.packages("devtools")
# devtools::install_github("uasolo/landmarkregUtils")
library(landmarkregUtils)
```

```{r}
la_long <- la_f |> 
  dplyr::filter(Current.Phone.Class == "Consonant") |> 
  pivot_longer(c(X, Y), names_to = "dim") |> 
  group_by(dim, participant) |> 
  mutate(
    value = (value - mean(value)) / sd(value)
  ) |> 
  ungroup()

# build a multiFunData object
curves_fun_2d <- lapply(c("X", "Y"), function(y)
  long2irregFunData(la_long |> filter(dim == {{y}}),
                    id = "Unique.ID",
                    time = "Knot",
                    value = "value") |> 
    as.funData()
) |> 
  multiFunData()

# Compute FPCA
n_pc <- 2
mfpca <- MFPCA(curves_fun_2d,
               M = n_pc,
               uniExpansions = list(list(type = "uFPCA", 8),list(type = "uFPCA", 8))
               # uniExpansions = list(list(type = "uFPCA", 4),list(type = "uFPCA", 4))
)

# Prop of explained var
mfpca$values  / sum( mfpca$values)
```

```{r}
# scores st. dev.
sd_fun <- mfpca$values |> sqrt()
# PC curves to be plotted
pc_curves <- expand_grid(PC = 1:n_pc,
                        dim = 1:2, 
                        sd_frac = seq(-1, 1, by=.25)) |>
  group_by(PC, dim, sd_frac) |>
  reframe(
    funData2long1(
      mfpca$meanFunction[[dim]] +
        sd_frac * sd_fun[PC] * mfpca$functions[[dim]][PC],
      time= "knot", value = "value")
  ) |> 
  mutate(dim = factor(dim, levels = c(2,1), labels = c('Y', 'X')))

ggplot(pc_curves) +
  aes(x = knot, y = value, group = sd_frac, color = sd_frac) +
  geom_line() +
  scale_color_gradient2(low = "blue", mid = "grey", high = "orangered",
                        breaks = c(-1, 0 , 1)) +
  facet_grid(dim ~ PC,
             scales = "free_y",
             labeller = labeller(PC = ~ str_glue("PC{.x}"))) + #,
                                 # dim = Dimlabels)) +
  labs(color = expression(frac(s[k], sigma[k]))) +
  geom_line(data = pc_curves |> filter(sd_frac == 0), color = 'black', linewidth = 1.2) +
  # mytheme +
  theme(legend.position = "right",
        axis.title.y = element_blank())
```

```{r}
pc_curves_wide <- pc_curves |> 
  pivot_wider(names_from = dim)

pc_curves_wide |> 
  ggplot(aes(x = X, y = Y, group = sd_frac, color = sd_frac)) +
  geom_path() +
  scale_color_gradient2(low = "#762a83", mid = "grey", high = "#1b7837", breaks = c(-1, 0 , 1)) +
  facet_grid(cols = vars(PC), labeller = labeller(PC = ~ str_glue("PC{.x}"))) +
  coord_fixed()
```


```{r}
# collect PC scores
pc_scores <- mfpca$scores |>
  `colnames<-`( paste0("PC", 1:n_pc)) |>
  as_tibble() |>
  bind_cols(la_long |> distinct(Unique.ID, emph, vowel, Consonant.Manner, vowel.Height, vowel.Frontness, participant), .)

# scatterplot PC scores s1 and s2 by Category
pc_scores |> 
  ggplot(aes(x = PC1, y = PC2, color = emph)) +
  geom_point() +
  facet_grid(cols = vars(vowel), rows = vars(Consonant.Manner)) +
  scale_color_brewer(palette = "Dark2")

pc_scores |> 
  ggplot(aes(x = PC1, y = PC2, colour = emph, shape = vowel, label = vowel)) +
  # geom_point() +
  geom_text(size = 2) +
  scale_color_brewer(palette = "Dark2") +
  stat_ellipse() +
  facet_wrap(vars(participant))
```

```{r}
pc_scores |> 
  ggplot(aes(vowel, PC1, colour = emph)) +
  geom_jitter(position = position_jitterdodge(), alpha = 0.5) +
  scale_color_brewer(palette = "Dark2") +
    facet_wrap(vars(participant))

pc_scores |> 
  ggplot(aes(vowel, PC2, colour = emph)) +
  geom_jitter(position = position_jitterdodge(), alpha = 0.5) +
  scale_color_brewer(palette = "Dark2") +
    facet_wrap(vars(participant))
```

